#https://stat.ethz.ch/pipermail/r-help//2013-January/344429.html
#' Predict
#' ##' Plots predicted surival curves from objects generated by the predicttvcure function.
#' @param model A model of class tvcure.
#' @param variable Variable to produce predictions for
#' @param CI Logical value indicating whether predictions and confidence intervals should be estimated using maximum simulated likelihood
#' @param nsims The number of simulated coefficient valeus to estimate when computing confidence intervals.
#' @param Logical value indicating whether graphs should be printed in black and white.
#' @param xlab A label for the x-axis.
#' @param ylab A label for the y-axis.
#' @param internals A logical value indicating whether the predictions should be returned. If FALSE, only the graph will be returned.

prediction4 <- function(model, variable = NULL, values = NULL, newX = NULL, newZ = NULL,
                        type = c("basesurv", "condsurv", "popsurv", "uncureprob"),
                        CI = T, nsims = 1000, bw = F,
                        xlab = "Time", legendtitle = NULL,
                        ylab = "Predicted Survival Probability") {

  # Setup -------------------------------------------------------------------

  require(ggplot2)
  # call <- match.call()
  if (!inherits(model, "tvcure")) stop("Model must be a tvcure object")
  s0 = as.matrix(model$Survival, ncol = 1)
  # H0 = as.matrix(model$BaseHaz, ncol = 1)
  nobs = nrow(s0)
  beta <- model$beta
  gamma <- model$gamma
  bnames <- model$bnames
  gnames <- model$gnames
  link <- model$link
  Status <- model$Status
  Time <- model$Time[order(model$Time)]
  X <- model$X
  Z <- model$Z
  type = match.arg(type)

  # Create dataset for predictions -----------------------------------------------------------
  if (is.null(newX)) {
    newX <- apply(X, 2, median)
    newX <- matrix(rep(newX, length(values)), ncol = length(newX), byrow = T)
    colnames(newX) <- bnames
    if (variable %in% bnames) newX[, variable] <- values
  }
  newX <- as.matrix(newX)
  nx <- nrow(newX)

  if (is.null(newZ)) {
    newZ <- apply(Z, 2, median)
    newZ <- matrix(rep(newZ, length(values)), ncol = length(newZ), byrow = T)
    colnames(newZ) <- gnames
    if (variable %in% gnames) newZ[, variable] <- values
  }
  newZ <- as.matrix(newZ)
  nz <- nrow(newZ)

  vcovb <- model$vcovb
  vcovg <- model$vcovg

  # Create predictions ------------------------------------------------------------------
  # Without CIs
  if (CI == F) {
    if (link == "logit") {
      uncureprob <- exp(gamma %*% t(newZ)) / (1 + exp(gamma %*% t(newZ)))
    }
    if (link == "probit") {
      uncureprob <- pnorm(gamma %*% t(newZ))
    }

    condsurv = array(0, dim = c(nobs, nx))
    ebetaX = exp(model$beta %*% t(newX))
    for (i in 1:nx) {
      condsurv[, i] = s0^ebetaX[i]
    }

    popsurv = array(0, dim = c(nobs, nrow(newX)))
    for (i in 1:nobs) {
      for (j in 1:nrow(newX)) {
        popsurv[i, j] = uncureprob[j] * condsurv[i, j] + (1 - uncureprob[j])
      }
    }
    s0      <- s0[order(s0, decreasing = T)]
    condsurv <- condsurv[order(condsurv[, 1], decreasing = T), ]
    popsurv    <- popsurv[order(popsurv[, 1], decreasing = T), ]
  } else { ## With CIs =========================================================================

    Coef_smplb <- MASS::mvrnorm(n = nsims, mu = beta, Sigma = vcovb)
    Coef_smplg <- MASS::mvrnorm(n = nsims, mu = gamma, Sigma =  vcovg)

    # Estimate nsims simulated values of uncureprob
    if (link == "logit") {
      uncureprobsims <- exp(Coef_smplg %*% t(newZ)) / (1 + exp(Coef_smplg %*% t(newZ)))
    }
    if (link == "probit") {
      uncureprobsims <- pnorm(Coef_smplg %*% t(newZ))
    }
    uncuremean = apply(uncureprobsims, 2, mean)
    uncurelo   = apply(uncureprobsims, 2, quantile, 0.05)
    uncurehi   = apply(uncureprobsims, 2, quantile, 0.95)

    # Simulate baseline hazard
    s0sim <- matrix(nrow = nsims, ncol = nobs)
    for (j in 1:nsims) {
      s0sim[j, ] <- as.vector(s0)^exp(Coef_smplb[j, ] %*% t(model$X))
    }
    s0mean <- sort(apply(s0sim, 2, mean), decreasing = T)
    s0lo   <- sort(apply(s0sim, 2, quantile, 0.05), decreasing = T)
    s0hi   <- sort(apply(s0sim, 2, quantile, 0.95), decreasing = T)

    # Obtain simulated values of condsurv and popsurv
    ebetaXsim <- exp(Coef_smplb %*% t(newX))
    condsurvsims <- array(NA, dim = c(nsims, nobs, nrow(newX)))
    popsurvsims    <- array(NA, dim = c(nsims, nobs, nrow(newX)))

    if (type == "condsurv" | type == "popsurv") {
      for (i in 1:nsims) {
        for (k in 1:nrow(newX)) {
          condsurvsims[i, , k] <- s0sim[i, ]^ebetaXsim[i, k]
          popsurvsims[i, , k] <- uncureprobsims[i, k] *
            condsurvsims[i, , k] + (1 - uncureprobsims[i, k])
        }
      }
    }


    condsurvmean <- matrix(nrow = nobs, ncol = dim(newZ))
    condsurvlo   <- matrix(nrow = nobs, ncol = dim(newZ))
    condsurvhi   <- matrix(nrow = nobs, ncol = dim(newZ))
    popsurvmean    <- matrix(nrow = nobs, ncol = dim(newZ))
    popsurvlo      <- matrix(nrow = nobs, ncol = dim(newZ))
    popsurvhi      <- matrix(nrow = nobs, ncol = dim(newZ))

    for (k in 1:nrow(newX)) {
      if (type == "condsurv") {
        condsurvmean[, k] <- sort(apply(condsurvsims[, , k], 2, mean), decreasing = T)
        condsurvlo[, k]   <- sort(apply(condsurvsims[, , k], 2, quantile, 0.05), decreasing = T)
        condsurvhi[, k]   <- sort(apply(condsurvsims[, , k], 2, quantile, 0.95), decreasing = T)
      }
      if (type == "popsurv") {
        popsurvmean[, k]    <- sort(apply(popsurvsims[, , k], 2, mean), decreasing = T)
        popsurvlo[, k]      <- sort(apply(popsurvsims[, , k], 2, quantile, 0.05), decreasing = T)
        popsurvhi[, k]      <- sort(apply(popsurvsims[, , k], 2, quantile, 0.95), decreasing = T)
      }
    }

  } # close CI = T else loop
browser()
  # Plot Setup --------------------------------------------------------------
  if (bw == T) {
    splot <- ggplot() + theme_bw()
  } else {
    splot <- ggplot() + theme(panel.border = element_rect(colour = "black", fill = NA))
  }

  # Uncureprob Plot ---------------------------------------------------------
  if (type == "uncureprob") {
    if (CI == F) {
      splot <- ggplot(mapping = aes(x = values, y = as.vector(uncureprob))) + geom_point()
    } else {
      splot <- ggplot(mapping = aes(x = values, y = as.vector(uncuremean))) + geom_point() +
        geom_errorbar(width = (length(values)/10),
                      mapping = aes(x = values, ymin = uncurelo, ymax = uncurehi), colour = "black")
    }
    splot <- splot + scale_x_continuous(breaks = values) + ylab("Probability of Failure") +
      xlab(variable) + theme(legend.position = "none") + theme_bw()
  }

  # Basesurv Plot -----------------------------------------------------------

  if (type == "basesurv") {
    if (CI == F) {
      splot <- splot + geom_line(mapping = aes(Time, s0))
    } else {
      splot <- splot + geom_line(mapping = aes(Time, s0mean)) +
        geom_ribbon(aes(x = Time, ymin = s0lo, ymax = s0hi), alpha=0.2)
    }
    splot = splot + ylab(ylab) + xlab(variable)# +
  }

  # condsurv Plot ------------------------------------------------------------
  if (type == "condsurv") {

    # Structure data
    if (CI == F) {
      scm  <- split(condsurv, rep(1:ncol(condsurv), each = nrow(condsurv)))
      for (i in 1:length(scm)) {
        scm[[i]] <- cbind(scm[[i]], Time, num = i)
      }
      scf <- as.data.frame(do.call(rbind, scm))
      colnames(scf) <- c("scm", "Time", "num")
    } else {
      scm  <- split(condsurvmean, rep(1:ncol(condsurvmean), each = nrow(condsurvmean)))
      sclo <- split(condsurvlo, rep(1:ncol(condsurvlo), each = nrow(condsurvlo)))
      schi <- split(condsurvhi, rep(1:ncol(condsurvhi), each = nrow(condsurvhi)))
      for (i in 1:length(scm)) {
        scm[[i]] <- cbind(scm[[i]], Time, num = i, sclo[[i]], schi[[i]])
      }
      scf <- as.data.frame(do.call(rbind, scm))
      colnames(scf) <- c("scm", "Time", "num", "sclo", "schi")
    }

    # Plot line
    if (bw == F) {
      splot = splot + geom_line(scf, mapping = aes(Time, scm, col = as.factor(num),
                                                   linetype = as.factor(num))) +
        labs(linetype = legendtitle, col = legendtitle)
    } else {
      splot = splot + geom_line(scf, mapping = aes(Time, scm, linetype = as.factor(num))) +
        labs(linetype = legendtitle)
    }

    # Add CIs
    if (CI == T) {
      if (bw == F) {
        splot = splot + geom_ribbon(scf, mapping = aes(x = Time, ymin = sclo,
                                                       ymax = schi, col = as.factor(num),
                                                       fill = as.factor(num),
                                                       linetype = as.factor(num)), alpha=0.2) +
          labs(fill = legendtitle, linetype = legendtitle, col = legendtitle)
      } else {
        splot = splot + geom_ribbon(scf, mapping = aes(x = Time, ymin = sclo, ymax = schi,
                                                       linetype = as.factor(num)), alpha=0.2) +
          labs(linetype = legendtitle)
      }
    }
    splot = splot + ylab(ylab) + xlab(xlab)
  }

  # popsurv Plot ---------------------------------------------------------------
  if (type == "popsurv") {
    vals <- round(values, 1)
    # Structure data
    if (CI == F) {
      spm  <- split(popsurv, rep(1:ncol(popsurv), each = nrow(popsurv)))
      for (i in 1:length(spm)) {
        spm[[i]] <- cbind(spm[[i]], Time, num = i)
      }
      spf <- as.data.frame(do.call(rbind, spm))
      colnames(spf) <- c("spm", "Time", "num")
    } else {
      spm  <- split(popsurvmean, rep(1:ncol(popsurvmean), each = nrow(popsurvmean))) # two matrices of simulated popsurvs
      splo <- split(popsurvlo, rep(1:ncol(popsurvlo), each = nrow(popsurvlo)))
      sphi <- split(popsurvhi, rep(1:ncol(popsurvhi), each = nrow(popsurvhi)))
      for (i in 1:length(spm)) {
        spm[[i]] <- cbind(spm[[i]], Time, num = i, splo[[i]], sphi[[i]])
      }
      spf <- as.data.frame(do.call(rbind, spm))
      colnames(spf) <- c("spm", "Time", "num", "splo", "sphi")
    }

    # Plot line
    if (bw == F) {
      splot = splot +
        geom_line(spf, mapping = aes(Time, spm, col = as.factor(num), linetype = as.factor(num))) +
        labs(linetype = legendtitle, col = legendtitle, fill = legendtitle)
    } else {
      splot = splot +
        geom_line(spf, mapping = aes(Time, spm, linetype = as.factor(num))) +
        labs(linetype = legendtitle)
    }

    splot + scale_fill_discrete(labels = vals)

    # Add CIs
    if (CI == T) {
      if (bw == F) {
        splot = splot + geom_ribbon(spf, mapping = aes(x = Time, ymin = splo, ymax = sphi,
                                                       col = as.factor(num),
                                                       fill = as.factor(num),
                                                       linetype = as.factor(num)), alpha = 0.2)# +
          labs(fill = legendtitle, linetype = legendtitle, col = legendtitle)
      } else {
        splot = splot + geom_ribbon(spf, mapping = aes(x = Time, ymin = splo, ymax = sphi,
                                                       linetype = as.factor(num)), alpha = 0.2) +
          labs(linetype = legendtitle)
      }
    }
    splot = splot + ylab(ylab) + xlab(xlab) +
      scale_linetype_discrete(labels = vals)  +
      scale_color_discrete(labels = vals) +
      scale_fill_discrete(labels = vals)

  }

  # Output ------------------------------------------------------------------
  # if (internals == F) {
    return(splot)
  # } else {
  #   if (CI == F) {
  #     structure(list(uncureprob = uncureprob,
  #                    s0 = s0, condsurv = condsurv, popsurv = popsurv,
  #                    Survival = model$Survival,
  #                    link = link, Time = Time, CI = CI,
  #                    newX = newX, newZ = newZ, variable = variable, splot = splot),
  #               class = "predicttvcure")
  #
  #   } else {
  #     structure(list(uncuremean = uncuremean, uncurelo = uncurelo, uncurehi = uncurehi,
  #                    s0mean = s0mean, s0lo = s0lo, s0hi = s0hi,
  #                    condsurvmean, condsurvlo, condsurvhi,
  #                    Survival = model$Survival,
  #                    popsurvmean = popsurvmean, popsurvlo = popsurvlo, popsurvhi = popsurvhi,
  #                    link = link, Time = Time, CI = CI,
  #                    newX = newX, newz = newZ, variable = variable, splot = splot),
  #               class = "predicttvcure")
  #   }
  # }
}
