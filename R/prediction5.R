#https://stat.ethz.ch/pipermail/r-help//2013-January/344429.html
#' Predict
#' ##' Plots predicted surival curves from objects generated by the predicttvcure function.
#' @param model A model of class tvcure.
#' @param variable Variable to produce predictions for
#' @param CI Logical value indicating whether predictions and confidence intervals should be estimated using maximum simulated likelihood
#' @param nsims The number of simulated coefficient valeus to estimate when computing confidence intervals.
#' @param Logical value indicating whether graphs should be printed in black and white.
#' @param xlab A label for the x-axis.
#' @param ylab A label for the y-axis.
#' @param internals A logical value indicating whether the predictions should be returned. If FALSE, only the graph will be returned.

prediction5 <- function(model, type = c("basesurv", "spop", "suncure", "uncureprob"),
                        variable = NULL, values = NULL,
                        CI = T, nsims = 1000)
                       # bw = F, xlab = "Time", legendtitle = NULL,
                        #ylab = "Predicted Survival Probability", internals = F) {

  # Setup -------------------------------------------------------------------
  # require(ggplot2)

  if (!inherits(model, "tvcure")) stop("Model must be a tvcure object")

  # call <- match.call()
  type = match.arg(type)

  beta  <- model$parameters$beta
  gamma <- model$parameters$gamma
  vcovb <- model$parameters$vcovb
  vcovg <- model$parmaters$vcovg

  bnames <- model$varnames$bnames
  gnames <- model$varnames$gnames

  s0 = as.matrix(model$Survival, ncol = 1)
  H0 = as.matrix(model$BaseHaz, ncol = 1)

  X <- model$data$X
  Z <- model$data$Z

  nx <- nrow(X)
  nz <- nrow(Z)

  Status <- model$data$Status
  Time   <- model$data$Time[order(model$data$Time)]

  nobs = nrow(s0)
  link <- model$options$link

  # if (is.null(legendtitle)) {
  #   legendtitle <- variable
  # }

  # if (!is.null(values)) vals <- round(values, 1)

  browser()
  # Create dataset for predictions -----------------------------------------------------------
  # if (is.null(X)) {
  #   X <- apply(X, 2, median)
  #   X <- matrix(rep(X, length(values)), ncol = length(X), byrow = T)
  #   colnames(X) <- bnames
  #   if (variable %in% bnames) X[, variable] <- values
  # }
  # X <- as.matrix(X)

  # if (is.null(Z)) {
  #   Z <- apply(Z, 2, median)
  #   Z <- matrix(rep(Z, length(values)), ncol = length(Z), byrow = T)
  #   colnames(Z) <- gnames
  #   if (variable %in% gnames) Z[, variable] <- values
  # }
  # Z <- as.matrix(Z)

  # browser()
  # Create predictions ------------------------------------------------------------------
  # Without CIs
  if (CI == F) {
    if (link == "logit") {
      uncureprob <- exp(gamma %*% t(Z)) / (1 + exp(gamma %*% t(Z)))
    }
    if (link == "probit") {
      uncureprob <- pnorm(gamma %*% t(Z))
    }

    suncure = array(0, dim = c(nobs, nx))
    ebetaX = exp(beta %*% t(X))
    for (i in 1:nx) {
      suncure[, i] = s0^ebetaX[i]
    }


    spop = array(0, dim = c(nobs, nrow(X)))
    for (i in 1:nobs) {
      for (j in 1:nrow(X)) {
        spop[i, j] = uncureprob[j] * suncure[i, j] + (1 - uncureprob[j])
      }
    }
    s0      <- s0[order(s0, decreasing = T)]
    suncure <- suncure[order(suncure[, 1], decreasing = T), ]
    spop    <- spop[order(spop[, 1], decreasing = T), ]
  } else { # With CIs ----------------------------------------------------------


    Coef_smplb <- MASS::mvrnorm(n = nsims, mu = beta, Sigma = vcovb)
    Coef_smplg <- MASS::mvrnorm(n = nsims, mu = gamma, Sigma =  vcovg)

    # Estimate nsims simulated values of uncureprob
    if (link == "logit") {
      uncureprobsims <- exp(Coef_smplg %*% t(Z)) / (1 + exp(Coef_smplg %*% t(Z)))
    }
    if (link == "probit") {
      uncureprobsims <- pnorm(Coef_smplg %*% t(Z))
    }
    uncuremean = apply(uncureprobsims, 2, mean)
    uncurelo   = apply(uncureprobsims, 2, quantile, 0.05)
    uncurehi   = apply(uncureprobsims, 2, quantile, 0.95)

    # Simulate baseline hazard
    s0sim <- matrix(nrow = nsims, ncol = nobs)
    for (j in 1:nsims) {
      s0sim[j, ] <- as.vector(s0)^exp(Coef_smplb[j, ] %*% t(model$X))
    }
    s0mean <- sort(apply(s0sim, 2, mean), decreasing = T)
    s0lo   <- sort(apply(s0sim, 2, quantile, 0.05), decreasing = T)
    s0hi   <- sort(apply(s0sim, 2, quantile, 0.95), decreasing = T)

    # Obtain simulated values of suncure and spop
    ebetaXsim <- exp(Coef_smplb %*% t(X)) #mark
    suncuresims <- array(NA, dim = c(nsims, nobs, nrow(X)))
    spopsims    <- array(NA, dim = c(nsims, nobs, nrow(X)))


    if (type == "suncure" | type == "spop") {
      for (i in 1:nsims) {
        for (k in 1:nrow(X)) {
          suncuresims[i, , k] <- s0sim[i, ]^ebetaXsim[i, k]
          spopsims[i, , k] <- uncureprobsims[i, k] *
            suncuresims[i, , k] + (1 - uncureprobsims[i, k])
        }
      }
    }

    suncuremean <- matrix(nrow = nobs, ncol = dim(Z))
    suncurelo   <- matrix(nrow = nobs, ncol = dim(Z))
    suncurehi   <- matrix(nrow = nobs, ncol = dim(Z))
    spopmean    <- matrix(nrow = nobs, ncol = dim(Z))
    spoplo      <- matrix(nrow = nobs, ncol = dim(Z))
    spophi      <- matrix(nrow = nobs, ncol = dim(Z))

      for (k in 1:nrow(X)) {
        if (type == "suncure") {
          suncuremean[, k] <- sort(apply(suncuresims[, , k], 2, mean), decreasing = T)
          suncurelo[, k]   <- sort(apply(suncuresims[, , k], 2, quantile, 0.05), decreasing = T)
          suncurehi[, k]   <- sort(apply(suncuresims[, , k], 2, quantile, 0.95), decreasing = T)
        }
        if (type == "spop") {
          spopmean[, k]    <- sort(apply(spopsims[, , k], 2, mean), decreasing = T)
          spoplo[, k]      <- sort(apply(spopsims[, , k], 2, quantile, 0.05), decreasing = T)
          spophi[, k]      <- sort(apply(spopsims[, , k], 2, quantile, 0.95), decreasing = T)
        }
      }

  } # close CI == T else loop

  if (CI == F) {
    structure(list(uncureprob = uncureprob,
                   s0 = s0, suncure = suncure, spop = spop,
                   link = link, Time = Time, CI = CI,
                   X = X, Z = Z, variable = variable)
              class = "predicttvcure")
  } else {
    structure(list(uncuremean = uncuremean, uncurelo = uncurelo, uncurehi = uncurehi,
                   s0mean = s0mean, s0lo = s0lo, s0hi = s0hi,
                   suncuremean, suncurelo, suncurehi,
                   spopmean = spopmean, spoplo = spoplo, spophi = spophi,
                   link = link, Time = Time, CI = CI,
                   X = X, Z = Z, variable = variable)
              class = "predicttvcure")
  }
}
