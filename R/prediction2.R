#' Predict
#' ##' Plots predicted surival curves from objects generated by the predicttvcure function.
#' @param model Model returned from tvcure function.
#' @param variable Variable to produce predictions for
#' @param CI Logical value indicating whether predictions and confidence intervals should be estimated using maximum simulated likelihood
#' @param nsims
#' @param xlab A label for the x-axis.
#' @param ylab A label for the y-axis.

prediction2 <- function(model, variable, values,
                        type = c("basesurv", "spop", "suncure", "uncureprob"),
                        CI = F, nsims = 1000,
                        xlab = "Time", legendtitle = NULL,
                        ylab = "Predicted Survival Probability", lty = 2) {

  require(ggplot2)
  call <- match.call()
  if (!inherits(model, "tvcure")) stop("Model must be a tvcure object")
  s0 = as.matrix(model$Survival, ncol = 1)
  nobs = nrow(s0)
  beta <- model$beta
  gamma <- model$gamma
  bnames <- model$bnames
  gnames <- model$gnames
  link <- model$link
  Status <- model$Status
  Time <- model$Time[order(model$Time)]
  X <- model$X
  Z <- model$Z
  if (is.null(legendtitle)) {
    legendtitle <- variable
  }
  clstatus <- foreach::getDoParRegistered()
  if (foreach::getDoParRegistered() == T) cl <- foreach::getDoSeqName()
  if (foreach::getDoParRegistered() == F) cl <- foreach::registerDoSEQ()
  pb <- txtProgressBar(max = nsims, style = 3)
  progress <- function(n) setTxtProgressBar(pb, n)
  opts <- list(progress = progress)
  #}


# Simulate Data -----------------------------------------------------------

  newX <- apply(X, 2, median)
  newX <- matrix(rep(newX, length(values)), ncol = length(newX), byrow = T)
  colnames(newX) <- bnames
  if (variable %in% bnames) newX[, variable] <- values
  newX <- as.matrix(newX)
  nx <- nrow(newX)

  newZ <- apply(Z, 2, median)
  newZ <- matrix(rep(newZ, length(values)), ncol = length(newZ), byrow = T)
  colnames(newZ) <- gnames
  if (variable %in% gnames) newZ[, variable] <- values
  newZ <- as.matrix(newZ)
  nz <- nrow(newZ)
browser()

# No CIs ------------------------------------------------------------------

  if (CI == F) {
    if (link == "logit") {
      uncureprob <- exp(gamma %*% t(newZ)) / (1 + exp(gamma %*% t(newZ)))
    }
    if (link == "probit") {
      uncureprob <- pnorm(gamma %*% t(newZ))
    }

    suncure = array(0, dim = c(nobs, nx))
    ebetaX = exp(model$beta %*% t(newX))
    for (i in 1:nx) {
      suncure[, i] = s0^ebetaX[i]
    }

    spop = array(0, dim = c(nobs, nrow(newX)))
    for (i in 1:nobs) {
      for (j in 1:nrow(newX)) {
        spop[i, j] = uncureprob[j] * suncure[i, j] + (1 - uncureprob[j])
      }
    }
    s0      <- s0[order(s0, decreasing = T)]
    suncure <- suncure[order(suncure[, 1], decreasing = T), ]
    spop    <- spop[order(spop[, 1], decreasing = T), ]

    if (type == "uncureprob") {
      # p1 <- plot(values, as.vector(uncureprob),
      #            ylim = c(round(min(uncureprob), 2), round(max(uncureprob), 2)),
      #            xlim = c(0, nx - 1), ylab = "Probability of Failure", axes = F)
      # box()
      # axis(1, seq(0, 1, 1))
      # # axis(2, seq(round(min(uncureprob), 2), round(max(uncureprob), 2),
      # #             by = ((round(max(uncureprob), 2) - round(min(uncureprob), 2))/2)))
      # # splot <- ggplot(mapping = aes(values, as.vector(uncureprob))) + ylab(ylab) +
      # #   geom_point() + scale_x_discrete(breaks = values, limits = c(min(values), max(values))) # coord_fixed(xlim = )
      # # splot <- ggplot(mapping = aes(values, as.vector(uncureprob))) +
      #   # geom_dotplot(binaxis = 'y') + ylab(ylab)
      # xl <- c(min(values) + 0.10, max(values) + 0.10)
      # # yl <- c(min(uncureprob) + 0.10, max(uncureprob) + 0.10)
      # df <- as.data.frame(cbind(values, uncureprob = as.vector(uncureprob)))
      # splot <- ggplot(df, aes(values, uncureprob)) + ylab(ylab) +
      #   geom_point() + scale_x_discrete(breaks = values)
      #   #scale_y_discrete(limits = yl)# coord_fixed(xlim = )
      # splot <- ggplot(df, aes(values, uncureprob)) + ylab(ylab) +
      #   geom_dotplot(mapping = aes(y = uncureprob)) #  + scale_x_discrete(breaks = values)
      #   #scale_y_discrete(limits = yl)# coord_fixed(xlim = )
      # splot <- ggplot(mapping = aes(x=values, y= as.vector(uncureprob))) +
      #   geom_point() #,ymax)
      #   #geom_errorbar(width=.1, aes(ymin = value-ci, ymax=value+ci), colour="red") +
      #   #geom_errorbar(width=.1, aes(ymin = value-ci, ymax=value+ci), data=dfwc) +
      #   #geom_point(shape=21, size=3, fill="white") +
      # splot <- ggplot(mapping = aes(x=values, y= as.vector(uncureprob))) +
      #   geom_point()  + scale_x_continuous(breaks = values) + coord_fixed()

      # Make the graph with the 95% confidence interval
      splot <- ggplot(mapping = aes(x = values, y = as.vector(uncureprob))) + geom_point()
          geom_line()
          # geom_errorbar(width=.1) , aes(ymin=value-ci, ymax=value+ci)) +
          # geom_point(shape=21, size=3, fill="white")
    }
  #   ggplot(mapping = aes(values, y = as.vector(uncureprob), ymin = as.vector(uncureprob), ymax = as.vector(uncureprob))) + geom_pointrange(position=position_dodge(width=0.1))
  #   ggplot(mapping = aes(values, as.vector(uncureprob))) + geom_point(size = 4) #+
  # geom_errorbar(aes(ymax = U, ymin = L))
  #     #geom_line(position=position_dodge(width=0.1)) +

    if (type == "basesurv") {
      splot <- ggplot(mapping = aes(Time, s0)) + geom_line() +  ylab("Probability of Failure") + xlab(variable)
    }
    if (type == "suncure") {
      scm  <- split(suncure, rep(1:ncol(suncure), each = nrow(suncure)))
      for (i in 1:length(scm)) {
        scm[[i]] <- cbind(scm[[i]], Time, num = i)
      }
      scf <- as.data.frame(do.call(rbind, scm))
      colnames(scf) <- c("scm", "Time", "num")
      splot <- ggplot(scf, aes(Time, scm, col = as.factor(num), linetype = as.factor(num))) +
        geom_line() + labs(fill = legendtitle, linetype = legendtitle, col = legendtitle) +
        ylab(ylab)
    }
    if (type == "spop") {
      spm  <- split(spop, rep(1:ncol(spop), each = nrow(spop)))
      for (i in 1:length(spm)) {
        spm[[i]] <- cbind(spm[[i]], Time, num = i)
      }
      spf <- as.data.frame(do.call(rbind, spm))
      colnames(spf) <- c("spm", "Time", "num")
      splot <- ggplot(spf, aes(Time, spm, col = as.factor(num), linetype = as.factor(num))) +
        geom_line() + labs(fill = legendtitle, linetype = legendtitle, col = legendtitle) +
        ylab(ylab)
    }
  } else {
    mu = c(beta, gamma)
    Coef_smpl <- MASS::mvrnorm(n = nsims, mu = mu, Sigma = cov(diag(mu)))
    Coef_smplb <- Coef_smpl[, 1:length(beta)]
    Coef_smplg <- Coef_smpl[, (length(beta) + 1):ncol(Coef_smpl)]

    # Estimate nsims simulated values of uncureprob
    if (link == "logit") {
      uncureprobsims <- exp(Coef_smplg %*% t(newZ)) / (1 + exp(Coef_smplg %*% t(newZ)))
    }
    if (link == "probit") {
      uncureprobsims <- pnorm(Coef_smplg %*% t(newZ))
    }
    uncuremean = apply(uncureprobsims, 2, mean)
    uncurelo   = apply(uncureprobsims, 2, quantile, 0.05)
    uncurehi   = apply(uncureprobsims, 2, quantile, 0.95)

    # Simulate baseline hazard
    s0sim <- matrix(nrow = nsims, ncol = nobs)
    for (j in 1:nsims) {
      s0sim[j, ] <- as.vector(s0)^exp(Coef_smplb[j, ] %*% t(model$X))
    }
    s0mean <- sort(apply(s0sim, 2, mean), decreasing = T)
    s0lo   <- sort(apply(s0sim, 2, quantile, 0.05), decreasing = T)
    s0hi   <- sort(apply(s0sim, 2, quantile, 0.95), decreasing = T)

    # Obtain simulated values of suncure and spop
    ebetaXsim <- exp(Coef_smplb %*% t(newX))
    suncuresims <- array(NA, dim = c(nsims, nobs, nrow(newX)))
    spopsims    <- array(NA, dim = c(nsims, nobs, nrow(newX)))

    if (type == "suncure" | type == "spop")
    foreach (i = 1:nsims, .errorhandling = 'remove') %:%
    	# .options.snow = opts,
      # Take the uncureprob for var j and multiply by suncure[j, k]
      # foreach(i = 1:nobs, .options.snow = opts, .errorhandling = 'remove') %dopar
      # foreach(i = 1:nobs, .options.snow = opts, .errorhandling = 'remove') %:%
    	# for (j in 1:nobs) {
    		foreach (k = 1:nrow(newX)) %dopar% {
    			# spop[i, j] = uncureprobsims[i, j] * suncuresims[i, j] + (1 - uncureprobsims[i, j])
    			suncuresims[i, , k] <- s0sim[i, ]^ebetaXsim[i, k]
    		  if (type == "spop") spopsims[i, j, k]    <- uncureprobsims[i, k] * suncuresims[i, j, k] + (1 - uncureprobsims[i, k])
    		}
    	#}
    # }
browser()
    suncuremean <- matrix(nrow = nobs, ncol = dim(newZ)) # 284 x 2
    suncurelo   <- matrix(nrow = nobs, ncol = dim(newZ))
    suncurehi  <- matrix(nrow = nobs, ncol = dim(newZ))
    spopmean    <- matrix(nrow = nobs, ncol = dim(newZ))
    spoplo      <- matrix(nrow = nobs, ncol = dim(newZ))
    spophi      <- matrix(nrow = nobs, ncol = dim(newZ))

    foreach(i = 1:nsims, .options.snow = opts, .errorhandling = 'remove') %dopar% {
    # for (i in 1:nrow(newX)) {
      if (type == "suncure" | type == "spop") {
        # suncuremean[, i] <- sort(snow::parApply(cl, suncuresims[, , i], 2, mean), decreasing = T)
        # suncurelo[, i]   <- sort(snow::parApply(cl, suncuresims[, , i], 2, quantile, 0.05), decreasing = T)
        # suncurehi[, i]   <- sort(snow::parApply(cl, suncuresims[, , i], 2, quantile, 0.95), decreasing = T)
        suncuremean[, i] <- sort(apply(suncuresims[, , i], 2, mean), decreasing = T)
        suncurelo[, i]   <- sort(apply(suncuresims[, , i], 2, quantile, 0.05), decreasing = T)
        suncurehi[, i]   <- sort(apply(suncuresims[, , i], 2, quantile, 0.95), decreasing = T)
      }
      if (type == "spop") {
        spopmean[, i]    <- sort(apply(spopsims[, , i], 2, mean), decreasing = T)
        spoplo[, i]      <- sort(apply(spopsims[, , i], 2, quantile, 0.05), decreasing = T)
        spophi[, i]      <- sort(apply(spopsims[, , i], 2, quantile, 0.95), decreasing = T)
      }
    }
# Plotting CIs ------------------------------------------------------------

    if (type == "uncureprob") {
      # require(plotrix)
      # p1 <- plotCI(values, uncuremean, ui = uncurehi[, i], hi = uncurelo[,])
      # box()
      # axis(1, seq(0, 1, 1))
      # axis(2, seq(round(min(uncurelo), 2), round(max(uncurehi), 2), by = ((round(max(uncurelo), 2) - round(min(uncurehi), 2))/2)))

      splot <- ggplot(mapping = aes(x = values, y = as.vector(uncuremean))) + geom_point() +
        geom_errorbar(width = .1, aes(ymin = uncurelo, ymax = uncurehi)) + scale_x_continuous(breaks = values) + ylab("Probability of Failure") + xlab(variable)
    }
    if (type == "basesurv") {
      splot <- ggplot(mapping = aes(Time, s0mean)) + geom_line() +
        geom_ribbon(aes(ymin = s0lo, ymax = s0hi), alpha=0.2) + ylab("Baseline Probability of Survival")
    }
    if (type == "suncure") {
      scm  <- split(suncuremean, rep(1:ncol(suncuremean), each = nrow(suncuremean)))
      sclo <- split(suncurelo, rep(1:ncol(suncurelo), each = nrow(suncurelo)))
      schi <- split(suncurehi, rep(1:ncol(suncurehi), each = nrow(suncurehi)))
      for (i in 1:length(scm)) {
        scm[[i]] <- cbind(scm[[i]], Time, num = i, sclo[[i]], schi[[i]])
      }
      scf <- as.data.frame(do.call(rbind, scm))
      colnames(scf) <- c("scm", "Time", "num", "sclo", "schi")
      splot <- ggplot(scf, aes(Time, scm, col = as.factor(num), linetype = as.factor(num))) +
        geom_line() + geom_ribbon(aes(ymin = sclo, ymax = schi, col = as.factor(num),
                                      fill = as.factor(num), linetype = as.factor(num)), alpha=0.2) +
        labs(fill = legendtitle, linetype = legendtitle, col = legendtitle) + ylab(ylab)
    }
    if (type == "spop") {
      spm  <- split(spopmean, rep(1:ncol(spopmean), each = nrow(spopmean)))
      splo <- split(spoplo, rep(1:ncol(spoplo), each = nrow(spoplo)))
      sphi <- split(spophi, rep(1:ncol(spophi), each = nrow(spophi)))
      for (i in 1:length(spm)) {
        spm[[i]] <- cbind(spm[[i]], Time, num = i, splo[[i]], sphi[[i]])
      }
      spf <- as.data.frame(do.call(rbind, spm))
      colnames(spf) <- c("spm", "Time", "num", "splo", "sphi")
      splot <- ggplot(spf, aes(Time, spm, col = as.factor(num), linetype = as.factor(num))) +
        geom_line() + geom_ribbon(aes(ymin = splo, ymax = sphi, col = as.factor(num),
                                      linetype = as.factor(num), fill = as.factor(num)), alpha=0.2) +
        labs(fill = legendtitle, linetype = legendtitle, col = legendtitle) + ylab(ylab)
    }
  }

# Output ------------------------------------------------------------------

  if (CI == F) {
    structure(list(uncureprob = uncureprob,
                   s0 = s0, suncure = suncure, spop = spop,
                   Survival = model$Survival,
                   link = link, Time = Time, CI = CI,
                   newX = newX, newZ = newZ, variable = variable, splot = splot),
              class = "predicttvcure")

  } else {
    structure(list(uncuremean = uncuremean, uncurelo = uncurelo, uncurehi = uncurehi,
                   s0mean = s0mean, s0lo = s0lo, s0hi = s0hi,
                   # scm = scm, sclo = sclo, schi = schi,
                   # spopmean = spopmean, spoplo = spoplo, spophi = spophi,
                   link = link, Time = Time, CI = CI,
                   newX = newX, newz = newZ, variable = variable, splot = splot),
              class = "predicttvcure")
  }
}

# done Order s0 in ao logical way
# TODO - are graphs behaving for suncure and spop
# done - Optimize the speed
# create error function if Z and X are not both specified when new
# create functionality to just get baselines for population
# Make it only spit out an image, not just a summary
# Black and white functionality
